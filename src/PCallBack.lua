---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Bergi.
--- DateTime: 27.05.2020 23:15
---
---
---
--[[
do
    local DestroyTimerOrigin = DestroyTimer -- записываем DestroyTimer в переменную
    local PauseTimerCached = PauseTimer -- локальная переменная используется для более быстрого вызова функции в дальнейшем
    function DestroyTimer(t)
        PauseTimerCached(t)  -- вызываем PauseTimer из переменной
        DestroyTimerOrigin(t) -- вызываем DestroyTimer из переменной
    end
end]]
UnitPauseCounter = {}
local origBlzPauseUnitEx = BlzPauseUnitEx
function BlzPauseUnitEx(whichUnit, flag)
    origBlzPauseUnitEx(whichUnit, flag)
    local h = GetHandleId(whichUnit)
    if not UnitPauseCounter[h] then
        UnitPauseCounter[h] = 0
    end
    if flag then
        UnitPauseCounter[h] = UnitPauseCounter[h] + 1
    else
        UnitPauseCounter[h] = UnitPauseCounter[h] - 1
    end
    --print("считаем паузы для ", GetUnitName(whichUnit), UnitPauseCounter[h])
end

local origResetUnitAnimation = ResetUnitAnimation
function ResetUnitAnimation(whichUnit)
    if UnitAlive(whichUnit) then
        origResetUnitAnimation(whichUnit, "stand")
        --print("reset from orin")
    end
end
local origSetUnitAnimation = SetUnitAnimation
function SetUnitAnimation(whichUnit, whichAnimation)
    if UnitAlive(whichUnit) then
        origSetUnitAnimation(whichUnit, whichAnimation)
    end
end

local origSetUnitAnimationByIndex = SetUnitAnimationByIndex
function SetUnitAnimationByIndex(whichUnit, whichAnimation)
    if UnitAlive(whichUnit) then
        origSetUnitAnimationByIndex(whichUnit, whichAnimation)
    end
end

local origQueueUnitAnimation = QueueUnitAnimation
function QueueUnitAnimation(whichUnit, whichAnimation)
    if UnitAlive(whichUnit) then
        origQueueUnitAnimation(whichUnit, whichAnimation)
    end
end

local origDestroyTimer = DestroyTimer
function DestroyTimer(t)

    if t == nil then
        t = GetExpiredTimer()
        if t == nil then
            --print("в функцию разрушения таймера передано что-то не то")
            return
        end
    end
    PauseTimer(t)
    GCountTimers = GCountTimers - 1
    origDestroyTimer(t)
end

local realTimerStart = TimerStart
GCountTimers = 0
TimerStart = function(timer, duration, repeating, callback)
    local pcallback = function()
        if callback == nil then
            return
        end
        local status, err = pcall(callback)
        if not status then
            print(err)
        end
    end
    GCountTimers = GCountTimers + 1
    --print("Запущено таймеров", GCountTimers)
    realTimerStart(timer, duration, repeating, pcallback)
end

local realTriggerAddAction = TriggerAddAction
TriggerAddAction = function(trig, callback)
    local pcallback = function()
        local status, err = pcall(callback)
        if not status then
            print(err)
        end
    end
    realTriggerAddAction(trig, pcallback)
end

function StartGCTracker()
    local t = CreateTimer()
    local track_gc
    local meta = {
        __gc = function(self)
            --print('GC is called at ' .. TimerGetElapsed(t))
            track_gc()
        end
    }

    track_gc = function()
        setmetatable({}, meta)
    end

    TimerStart(t, 86400, false)
    track_gc()
end



