---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by User.
--- DateTime: 28.09.2023 20:17
---
---




function InitTrig_BallMove()
    gg_trg_BallMove = CreateTrigger()
    DisableTrigger(gg_trg_BallMove)
    TriggerRegisterTimerEventPeriodic(gg_trg_BallMove, 0.03)
    TriggerAddAction(gg_trg_BallMove, function()

        local x, y = GetUnitXY(udg_Ball)
        local nx, ny = MoveXY(x, y, udg_BallSpeed, udg_BallFacing)
        local bounceFact = false
        --udg_BallFacing = CHKBouncing2(x, y, nx, ny, udg_BallSpeed)


        udg_BallFacing, bounceFact = CHKBouncing2(x, y, nx, ny, udg_BallSpeed) ---------------- баунсинг
        nx, ny = MoveXY(x, y, udg_BallSpeed, udg_BallFacing)
        if bounceFact then
            nx, ny = MoveXY(x, y, udg_BallSpeed, udg_BallFacing)
        end

        SetUnitPositionSmooth(udg_Ball, nx, ny)
        udg_BallSpeed = udg_BallSpeed - 0.50
        --print(udg_BallSpeed)
        BlzSetUnitFacingEx(udg_Ball, GetUnitFacing(udg_Ball) + udg_BallSpeed)

        if udg_BallSpeed <= 0.00 then
            DisableTrigger(GetTriggeringTrigger())
        else
        end
    end)
end

function InitTrig_Init ()
    gg_trg_Init = CreateTrigger()
    TriggerRegisterTimerEventSingle(gg_trg_Init, 2.00)
    TriggerAddAction(gg_trg_Init, function()
        SetUnitPathing(udg_Ball, false)
        --udg_BallFacing = (0.00 - AngleBetweenPoints(udg_BallPoint, udg_BallTempPoint))
        udg_BallFacing = AngleBetweenPoints(udg_BallTempPoint, udg_BallPoint)
    end)
end

function InitTrig_BallInit ()
    gg_trg_BallInit = CreateTrigger()
    TriggerRegisterUnitEvent(gg_trg_BallInit, udg_Ball, EVENT_UNIT_DAMAGED)
    TriggerAddAction(gg_trg_BallInit, function()
        --udg_Ball = gg_unit_e007_0258 --глобалка
        udg_BallPoint = GetUnitLoc(udg_Ball)
        if GetEventDamage() > 5 then
            udg_BallSpeed = udg_BallSpeed + 20
            udg_BallFacing = AngleBetweenPoints(GetUnitLoc(GetEventDamageSource()), udg_BallPoint)
            EnableTrigger(gg_trg_BallMove)

        end
        RemoveLocation(udg_BallPoint)
    end)
    --print("событие урона на месте")
end
udg_BallSpeed = 0
function InitBounceOnGUI()
    InitTrig_BallInit()
    InitTrig_Init()
    InitTrig_BallMove()
end

--------------------------------------------- ДРУГАЯ СИСТЕМА!!!!!!!
function StartHFOO(u, x, y)
    print("запуск рикошетного снаряда")
    local A = {}
    A.x = GetUnitX(u)
    A.y = GetUnitY(u)
    A.z = GetTerrainZ(A.x, A.y)
    local time = 1
    A.v = Vector:new(x - A.x, y - A.y, 0.00) --Vector:new(x, y, z)
    local dummy = CreateUnit(GetOwningPlayer(u), FourCC('hfoo'), A.x, A.y, Atan2(y - A.y, x - A.x) * bj_RADTODEG)
    UnitAddAbility(dummy, FourCC('Arav'))

    A.g = CreateGroup()

    --SaveInteger(H, GetHandleId(t), 0, A)
    TimerStart(CreateTimer(), 0.01, true, function()
        --local MyStruct A = LoadInteger( H, GetHandleId( GetExpiredTimer( ) ), 0 )
        --local x
        --local y
        local x1
        local y1
        local a
        local b = {} --был массив
        --print("avx=", A.v.x)
        local speed = 0.05
        --print(GetUnitName(A.dummy)," юнит???")a
        A.x = A.x + speed * A.v.x
        A.y = A.y + speed * A.v.y
        A.z = A.z + speed * A.v.z

        SetItemPosition(TempItem, A.x, A.y)
        SetItemVisible(TempItem, false)

        x = GetItemX(TempItem)
        y = GetItemY(TempItem)

        if (x - 1.00 > A.x or x + 1.00 < A.x) or (y - 1.00 > A.y or y + 1.00 < A.y) then
            --print("первое условие")
            A.x = A.x - speed * A.v.x
            A.y = A.y - speed * A.v.y
            A.z = A.z - speed * A.v.z

            -- right
            x = A.x + 5.00
            y = A.y
            SetItemPosition(TempItem, x, y)
            SetItemVisible(TempItem, false)

            x1 = GetItemX(TempItem)
            y1 = GetItemY(TempItem)

            b[0] = (x1 - 1.00 > x or x1 + 1.00 < x) or (y1 - 1.00 > y or y1 + 1.00 < y)

            --left
            x = A.x - 5.00
            y = A.y
            SetItemPosition(TempItem, x, y)
            SetItemVisible(TempItem, false)

            x1 = GetItemX(TempItem)
            y1 = GetItemY(TempItem)
            b[1] = (x1 - 1.00 > x or x1 + 1.00 < x) or (y1 - 1.00 > y or y1 + 1.00 < y)

            -- up
            x = A.x
            y = A.y + 5.00
            SetItemPosition(TempItem, x, y)
            SetItemVisible(TempItem, false)

            x1 = GetItemX(TempItem)
            y1 = GetItemY(TempItem)
            b[2] = (x1 - 1.00 > x or x1 + 1.00 < x) or (y1 - 1.00 > y or y1 + 1.00 < y)

            -- down
            x = A.x
            y = A.y - 5.00
            SetItemPosition(TempItem, x, y)
            SetItemVisible(TempItem, false)

            x1 = GetItemX(TempItem)
            y1 = GetItemY(TempItem)
            b[3] = (x1 - 1.00 > x or x1 + 1.00 < x) or (y1 - 1.00 > y or y1 + 1.00 < y)

            if b[0] or b[1] or b[2] or b[3] then
                --print("отражение")
                if b[0] or b[1] then
                    A.v.x = -A.v.x
                    --print("b0b1")
                else
                    A.v.y = -A.v.y
                    --print("b0b1 else")
                end
            else
                --print("b0b1b2b3 else")
                A.v.x = -A.v.x
                A.v.y = -A.v.y
            end
        else
            --// units
            --print("а перебор вообще есть?")
            GroupEnumUnitsInRange(TempGroup, GetUnitX(dummy), GetUnitY(dummy), 64, nil)
            GroupRemoveUnit(TempGroup, dummy)
            local e = nil
            while true do
                e = FirstOfGroup(TempGroup)
                --print("встретился с ", GetUnitName(e))
                if e == nil then
                    break
                    print("остановка")
                end
                GroupRemoveUnit(TempGroup, e)

                if not IsUnitInGroup(e, A.g) and UnitAlive(e) and e ~= dummy and time <= 0 then
                    -- and GetUnitTypeId(e) == FourCC('hfoo')
                    x1 = GetUnitX(e)
                    y1 = GetUnitY(e)
                    a = Atan2BJ(A.y - y1, A.x - x1)

                    --bj_lastCreatedUnit = CreateUnit(Player(0x00), 'u000', x1 + 24.00 * Cos(a), y1 + 24.00 * Sin(a), a * bj_RADTODEG)
                    --UnitApplyTimedLife(bj_lastCreatedUnit, 'BTLF', 2.00)
                    --SetUnitX(bj_lastCreatedUnit, x1 + 32.00 * Cos(a))
                    --SetUnitY(bj_lastCreatedUnit, y1 + 32.00 * Sin(a))
                    --SetUnitTimeScale(bj_lastCreatedUnit, 2.00)


                    --a = a + (a - (Atan2BJ(A.v.y, A.v.x) - 180.00)) --GetRandomReal(0,360)--
                    --local ang = a - 180.00 + 2.00 * (Atan2(GetUnitY(dummy) - y1, GetUnitX(dummy) - x1) * bj_RADTODEG)
                    --print("эффект отражения ", a, ang)
                    --set x = A.v.x
                    --A.v.x = (Cos(a) / A.v.x * Cos(a) - A.v.y * Sin(a)) * speed
                    --A.v.y = (Sin(a) / A.v.y * Cos(a) + x * Sin(a)) * speed
                    print("AVX до", A.v.x)
                    A.v.x, A.v.x = MoveXY(A.v.x, A.v.x, 50, a)
                    print("AVX после", A.v.x)
                    GroupClear(A.g)
                    GroupAddUnit(A.g, e)

                    time = 0.25
                end
            end
        end

        time = time - 0.01
        --print(A.time)
        if time <= 0.00 then
            GroupClear(A.g)
            --print("clear")
        end

        SetUnitX(dummy, A.x)
        SetUnitY(dummy, A.y)
        --print("Смещение на", A.x, A.y)
        --SetUnitFlyHeight(A.dummy, A.z - GetTerrainZ(A.x, A.y), 0.00)
    end)
end

--A = {}
function InitRicoshet()
    TempItem = CreateItem(FourCC('spsh'), 0.00, 0.00)
    TempGroup = CreateGroup()
    SetItemVisible(TempItem, false)
    print("конец инициализации рикошета")
    --InitBounceOnGUI()
end