---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Bergi.
--- DateTime: 01.12.2021 18:39
---
do
    Vector = {}
    Vector.__index = Vector
end

function Vector:new(x, y, z)
    local v = { x = x, y = y, z = z }
    setmetatable(v, self)
    return v
end

function Vector:copy()
    return Vector:new(self.x, self.y, self.z)
end

function Vector:dot(other)
    return self.x * other.x + self.y * other.y + self.z * other.z
end

function Vector:length()
    return math.sqrt(self.x * self.x + self.y * self.y + self.z * self.z)
end

function Vector:length2d()
    return math.sqrt(self.x * self.x + self.y * self.y)
end

function Vector:__mul(num)
    return Vector:new(self.x * num, self.y * num, self.z * num)
end
function VectorMulNumber(vector, num)
    return Vector:new(vector.x * num, vector.y * num, vector.z * num)
end

function Vector:__div(num)
    return Vector:new(self.x / num, self.y / num, self.z / num)
end

function Vector:normalize(clone)
    if clone then
        return self / self:length()
    end
    local l = self:length()
    self.x = self.x / l
    self.y = self.y / l
    self.z = self.z / l
    return self
end

function Vector:differenceRegardingUp(other)
    local a = self:angleBetweenUP()
    local b = other:angleBetweenUP()

    return math.max(a, b) - math.min(a, b);
end

function Vector:angleBetweenUP()
    return math.acos(self:dot(Vector:new(0, 1, 0)) / 1 / self:length())
end

function Vector:angleBetween(other)
    return math.acos(self:dot(other) / other:length() / self:length())
end

function Vector:yaw()
    return math.atan(self.y, self.x)
end

function Vector:pitch()
    return math.atan(self.z, self:length2d())
end

function Vector:yawPitchOffset(distance, yaw, pitch)
    --Add Bergi
    return Vector:new(
            distance * math.cos(yaw) * math.cos(pitch),
            distance * math.sin(yaw) * math.cos(pitch),
            distance * math.cos(pitch)
    )
end
function Distance(vector1, vector2)
    -- Add Oferist
    return DistanceBetweenXY(vector1.x, vector1.y, vector2.x, vector2.y)
end

function VectorSubtract(vector1, vector2)
    return Vector:new(vector1.x - vector2.x, vector1.y - vector2.y, vector1.z - vector2.z)
end

function VectorSum(vector1, vector2)
    return Vector:new(vector1.x + vector2.x, vector1.y + vector2.y, vector1.z + vector2.z)
end
function VectorMulVector(vector1, vector2)
    return Vector:new(vector1.x * vector2.x, vector1.y * vector2.y, vector1.z * vector2.z)
end

function Vector:angleBetween2Vectors(vector1, vector2)
    --возвращает угол - Bergi ебобо
    return AngleBetweenXY(vector1.x, vector1.y, vector2.x, vector2.y) / bj_DEGTORAD
end

function GetVectorFromPoint2D(x1, y1, x2, y2)
    return Vector:new(x2 - x1, y2, -y1, 0)
end
--- для системы рикошета
function DotProduct(v1, v2)
    local dot = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z
    print("dot", dot)
    return dot -- число
end

--
function Reflect(ray, normal)
    local dot = DotProduct(ray, normal)
    local a = -2 * dot --числ
    local b = VectorMulNumber(normal, a)
    local c = VectorSum(b, ray)
    local ref = c

    --return -2 * DotProduct(ray, normal) * normal + ray
    return ref
end
function GetNormal(a, b, c)
    local v1 = Vector:new(0, 0, 0)
    local v2 = Vector:new(0, 0, 0)
    local normal = Vector:new(0, 0, 0)

    v1.x = a.x - b.x
    v1.y = a.y - b.y
    v1.z = a.z - b.z

    v2.x = b.x - c.x
    v2.y = b.y - c.y
    v2.z = b.z - c.z

    local wrki = SquareRoot(math.sqrt(v1.y * v2.z - v1.z * v2.y) + math.sqrt(v1.z * v2.x - v1.x * v2.z) + math.sqrt(v1.x * v2.y - v1.y * v2.x))
    normal.x = (v1.y * v2.z - v1.z * v2.y) / wrki
    normal.y = (v1.z * v2.x - v1.x * v2.z) / wrki
    normal.z = (v1.x * v2.y - v1.y * v2.x) / wrki
    print("нормаль получена? ", normal.x, normal.y, normal.z)
    return normal -- vector3
end